  %Скрипт для GNU Octave
%читает результаты АЦП из файла out.txt и выводит их на график
%данные в файле хранятся по два байта, т.е. одно число 2047 выглядит как
%	2047 = 0b00000111 0b11111111 = 0x07 0xFF
%программа читает по одному байту и объединяет их в число
%также, т.к. из-за АЦП все числа начинаются с четырех нулей,
%эта программа проверяет, четные или нечетные байты в файле
%начинаются с нулей, и определяет, с какого байта начинается файл.

	clc,clear; %очистить вывод
	graphics_toolkit("fltk");%это специально для Октавы, в матлабе такого нет.

	%объявление констант, используемых микроконтроллером
	%можно найти в файле программы МК ../atmega/main.c
	f_cpu=19600000; 
	adc_clock_divider=16;
	time_step=1/(f_cpu/adc_clock_divider);
	V_gnd=0;
	V_ref=4.69;
	adc_digits=1024;

	%дальше код самой программы. она открывает файл out.txt
	%читает каждое число, состоящее из двух байт и выводит на график
	fclose('all') %сначала закрыть все ранее открытые файлы на всякий случай
	%SCILAB mclose('all')

	[file,error]=fopen('out.txt','r'); %открыть файл только для чтения
	%SCILAB [file,error]=mopen('out.txt','rb')

	while(1)%бесконечный цикл

		clf();%очистить график
		read_data=[];%просто инициализация массива для хранения результатов
		bytes = fread(file,'uint8'); %прочитать все байты из файла (uint8 значит как байты)

		%проверка порядка байтов
		odd_array=bytes(1:2:end);
		even_array=bytes(2:2:end);
		if all(odd_array<=3) %если все нечетные байты меньше трех, т.е. меньше 0b00000011
			start=1;%то первый байт в файле - старший, начнем преобразование с него
		else
			start=2;%иначе начнем преобразование со второго байта, который будет старшим
		end
		
		%цикл, в котором объединяем байты в числа в правильном порядке
		for i=start:2:size(bytes,1)-1%берем каждые 2 байта
		% size()-1 чтообы не вылезти за границы массива в следующей формуле
      
		 %если -1 то это не нужно 
			%if (i+1)>size(bytes,1)%если файл оканчивается старшим байтом, то выкидываем его
			  %continue;%продолжить цикл заново, т.к. конец файла
			%end
     %не нужно 
     
			number = bytes(i)*256+bytes(i+1);%соединить байты
              read_data = [read_data number];%присоединить к общему массиву
		
		end

		fseek(file,0);%установить курсор на начало файла для повторного чтения
		%SCILAB mseek(0)

		%вывести на график значения с учетом коэфф. в начале
		read_data = read_data*(V_ref-V_gnd)/adc_digits;
		time = [0:size(read_data,2)-1]*time_step;
		plot(time,read_data);
		pause(1);%обновлять график раз в 1 секунду
	end
  
