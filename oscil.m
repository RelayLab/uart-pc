%Скрипт для GNU Octave
%читает результаты АЦП из файла out.txt и выводит их на график
%данные в файле хранятся по два байта, т.е. одно число 2047 выглядит как
%	2047 = 0b00000111 0b11111111 = 0x07 0xFF
%программа читает по одному байту и объединяет их в число
%также, т.к. из-за АЦП все числа начинаются с четырех нулей,
%эта программа проверяет, четные или нечетные байты в файле
%начинаются с нулей, и определяет, с какого байта начинается файл.

	clc,clear; %очистить вывод
	graphics_toolkit("fltk");%это специально для Октавы, в матлабе такого нет.

	%объявление констант, используемых микроконтроллером
	%можно найти в файле программы МК ../atmega/main.c
	f_cpu=19600000;
	adc_clock_divider=16;
	time_step=1/(f_cpu/adc_clock_divider);
	V_gnd=0;
	V_ref=1.1;
	adc_digits=1024;

	%дальше код самой программы. она открывает файл out.txt
	%читает каждое число, состоящее из двух байт и выводит на график
	[file,error]=fopen('out.txt','r'); %открыть файл только для чтения

	while(1)%бесконечный цикл

		clf();%очистить график
		read_data=[];%просто инициализация массива для хранения результатов
		bytes = fread(file,'uint8'); %прочитать все байты из файла (uint8 значит как байты)

		%цикл с проверкой порядка байтов
		for i=1:2:size(bytes,1)%берем каждый нечетный байт
			if bytes(i)>7%если он начинается не с пяти нулей, т.е. больше чем 00000111
				is_hi_odd=false;%то первый байт в файле - младший
				start=2;%начинать преобразования со второго байта
			else
				is_hi_odd=true;%если все байты с пяти нулей, то старшие байты нечетные
				start=1;
			end
		end
		
		for i=start:2:size(bytes,1)%берем каждые 2 байта
			if (i+1)>size(bytes,1)%если файл оканчивается старшим байтом, то выкидываем его
				continue;%продолжить цикл заново, т.к. конец файла
			end
			number = bytes(i)*256+bytes(i+1);%соединить байты
              read_data = [read_data number];%присоединить к общему массиву
		
		end

		fseek(file,0);%установить курсор на начало файла для повторного чтения

		%вывести на график значения с учетом коэфф. в начале
		read_data = read_data*(V_ref-V_gnd)/adc_digits;
		time = [0:size(read_data,2)-1]*time_step;
		plot(time,read_data);
		pause(1);%обновлять график раз в 1 секунду
	end
